# -*- coding: utf-8 -*-
#
# Copyright (C) 2015-2020 Bitergia
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.


import json
import logging
import requests
from grimoirelab_toolkit.datetime import datetime_to_utc, datetime_utcnow
from grimoirelab_toolkit.uris import urijoin


from ...backend import (Backend,
                        BackendCommand,
                        BackendCommandArgumentParser)

from ...client import HttpClient
from ...errors import BaseError
from ...utils import DEFAULT_DATETIME

CATEGORY_MESSAGE = "comics"

MARVEL_URL = 'https://gateway.marvel.com/v1/public'
MAX_ITEMS = 1000
FLOAT_FORMAT = '{:.6f}'

logger = logging.getLogger(__name__)


class Marvel(Backend):
    """Marvel backend.

    This class retrieves the comics through a Marvel API.
    To access the server an API token is required, which must
    have enough permissions to read from the given channel.

    The origin of the data will be set to the `MARVEL_URL`
     i.e 'https://gateway.marvel.com/v1/public/'.


    :param api_token: token or key needed to use the API
    :param max_items: maximum number of items requested on the same query
    :param tag: label used to mark the data
    :param archive: archive to store/retrieve items
    :param ssl_verify: enable/disable SSL verification
    """
    version = '0.9.0'

    CATEGORIES = [CATEGORY_MESSAGE]

    def __init__(self, tag=None, archive=None, ssl_verify=False):
        origin = urijoin(MARVEL_URL, CATEGORY_MESSAGE, "?ts=1&apikey=")

        super().__init__(origin, tag=tag, archive=archive, ssl_verify=ssl_verify)
        self.client = None
        self.api_token = "?ts=1&apikey=5e0ce6bef48a467420ab10da790957e9&hash=14ad257fd4adf0d881cb9c49d2ca8ada"

    def fetch(self, category=CATEGORY_MESSAGE):
        """Fetch the comics from the channel.

        This method fetches the messages stored on the channel that were
        sent since the given date.

        :param category: the category of items to fetch
        :param from_date: obtain messages sent since this date

        :returns: a generator of messages
        """
        kwargs = {}
        items = super().fetch(category, **kwargs)

        return items

    def fetch_items(self, category, **kwargs):
        """Fetch the messages

        :param category: the category of items to fetch
        :param kwargs: backend arguments

        :returns: a generator of items
        """
        logger.info("Fetching data for '%s'", category)
        url = urijoin(MARVEL_URL, category)
        URL = url + self.api_token

        # hits_raw = self.client.hits()
        # hits = self.__parse_hits(hits_raw)

        # yield hits

        response = requests.get(URL)

        data = response.json()
        logger.info(data)
        logger.info("Fetch process completed")
        yield data

    @classmethod
    def has_archiving(cls):
        """Returns whether it supports archiving items on the fetch process.

        :returns: this backend supports items archive
        """
        return True

    @classmethod
    def has_resuming(cls):
        """Returns whether it supports to resume the fetch process.

        :returns: this backend does not support items resuming
        """
        return False

    @staticmethod
    def metadata_id(item):
        """Extracts the identifier from a Slack item.

        This identifier will be the mix of two fields because Slack
        messages does not have any unique identifier. In this case,
        'ts' and 'user' values (or 'bot_id' when the message is sent by a bot)
        are combined because there have been cases where two messages were sent
        by different users at the same time.
        """

        return item['id']

    @staticmethod
    def metadata_updated_on(item):
        """Extracts and coverts the update time from a Slack item.

        The timestamp is extracted from 'ts' field and converted
        to a UNIX timestamp.

        :param item: item generated by the backend

        :returns: a UNIX timestamp
        """
        return item['fetched_on']

    @staticmethod
    def metadata_category(item):
        """Extracts the category from a Slack item.

        This backend only generates one type of item which is
        'message'.
        """
        return CATEGORY_MESSAGE

    @staticmethod
    def parse_channel_info(raw_channel_info):
        """Parse a channel info JSON stream.

        This method parses a JSON stream, containing the information
        from a channel, and returns a dict with the parsed data.

        :param raw_channel_info

        :returns: a dict with the parsed information about a channel
        """
        result = json.loads(raw_channel_info)
        return result['channel']

    @staticmethod
    def parse_history(raw_history):
        """Parse a channel history JSON stream.

        This method parses a JSON stream, containing the history of
        a channel, and returns a list with the parsed data. It also
        returns if there are more messages that are not included on
        this stream.

        :param raw_history: JSON string to parse

        :returns: a tuple with a list of dicts with the parsed messages
            and 'has_more' value
        """
        result = json.loads(raw_history)
        return result['messages'], result['has_more']

    @staticmethod
    def parse_user(raw_user):
        """Parse a user's info JSON stream.

        This method parses a JSON stream, containing the information
        from a user, and returns a dict with the parsed data.

        :param raw_user: JSON string to parse

        :returns: a dict with the parsed user's information
        """
        result = json.loads(raw_user)
        return result['user']

    def _init_client(self, from_archive=False):
        """Init client"""

        return MarvelClient(self.api_token, self.archive,
                            from_archive, self.ssl_verify)

    def __get_or_fetch_user(self, user_id):
        if user_id in self._users:
            return self._users[user_id]

        logger.debug("User %s not found on client cache; fetching it", user_id)

        raw_user = self.client.user(user_id)
        user = self.parse_user(raw_user)

        self._users[user_id] = user
        return user


class MarvelClientError(BaseError):
    """Raised when an error occurs using the  Marvel client"""

    message = "%(error)s"


class MarvelClient(HttpClient):
    """Marvel API client.

    Client for fetching information from the Slack server
    using its REST API.

    :param api_token: key needed to use the API
    :param max_items: maximum number of items per request
    :param archive: an archive to store/read fetched data
    :param from_archive: it tells whether to write/read the archive
    :param ssl_verify: enable/disable SSL verification
    """
    URL = urijoin(MARVEL_URL, CATEGORY_MESSAGE)

    def __init__(self, api_token, archive=None, from_archive=False, ssl_verify=True):
        super().__init__(MARVEL_URL, archive=archive, from_archive=from_archive, ssl_verify=ssl_verify)
        self.api_token = api_token

    def conversation_members(self, conversation):
        """Fetch the number of members in a conversation, which is a supertype for public and
        private ones, DM and group DM.

        :param conversation: the ID of the conversation
        """
        members = 0

        resource = self.RCONVERSATION_INFO

        params = {
            self.PCHANNEL: conversation,
        }

        raw_response = self._fetch(resource, params)
        response = json.loads(raw_response)

        members += len(response["members"])
        while 'next_cursor' in response['response_metadata'] and response['response_metadata']['next_cursor']:
            params['cursor'] = response['response_metadata']['next_cursor']
            raw_response = self._fetch(resource, params)
            response = json.loads(raw_response)
            members += len(response["members"])

        return members

    def user(self, user_id):
        """Fetch user info."""

        resource = self.RUSER_INFO

        params = {
            self.PUSER: user_id
        }

        response = self._fetch(resource, params)

        return response

    @staticmethod
    def sanitize_for_archive(url, headers, payload):
        """Sanitize payload of a HTTP request by removing the token information
        before storing/retrieving archived items

        :param: url: HTTP url request
        :param: headers: HTTP headers request
        :param: payload: HTTP payload request

        :returns url, headers and the sanitized payload
        """
        if MarvelClient.AUTHORIZATION_HEADER in headers:
            headers.pop(MarvelClient.AUTHORIZATION_HEADER)

        return url, headers, payload

    def _fetch(self, resource, params):
        """Fetch a resource.

        :param resource: resource to get
        :param params: dict with the HTTP parameters needed to get
            the given resource
        """
        url = self.URL % {'resource': resource}
        headers = {
            self.AUTHORIZATION_HEADER: 'Bearer {}'.format(self.api_token)
        }

        logger.debug("Slack client requests: %s params: %s",
                     resource, str(params))

        r = self.fetch(url, payload=params, headers=headers)

        # Check for possible API errors
        result = r.json()

        if not result['ok']:
            raise MarvelClientError(error=result['error'])

        return r.text

    def __format_timestamp(self, ts, subtract=False):
        """Handle the timestamp value to be passed to the channels.history API endpoint. In
        particular, two cases are covered:

        - Since the minimum value supported by Slack is 0, the value 0.0 must be converted.
        - Slack does not include in its result the lower limit of the search if it has
          the same date of 'oldest'. To get this messages too, we subtract a low value to
          be sure the dates are not the same. To avoid precision problems it is subtracted
          by five decimals and not by six.

        :param ts: timestamp float value
        :param subtract: if True, `ts` is decreased by 0.00001
        """
        if ts == 0.0:
            return "0"

        processed = ts
        if processed > 0.0 and subtract:
            processed -= .00001

        processed = FLOAT_FORMAT.format(processed)

        return processed


class MarvelCommand(BackendCommand):
    """Class to run Marvel backend from the command line."""

    BACKEND = Marvel

    @classmethod
    def setup_cmd_parser(cls):
        """Returns the Slack argument parser."""

        parser = BackendCommandArgumentParser(cls.BACKEND,
                                              archive=True,
                                              ssl_verify=False)

        return parser